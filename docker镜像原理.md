# docker镜像原理

## 什么是镜像

在Docker中，一个镜像可以视为由多个层组成的堆栈。

## `hello-world`的Dockerfile

```dockerfile
FROM scratch
#从 0 开始构建。

COPY hello /
#将文件“hello”复制到镜像的根目录。

CMD ["/hello"]
#容器启动时，执行 /hello
```

## Base镜像

1. 不依赖其他镜像，从 scratch 构建。
2. 其它镜像可以之为基础进行扩展。

Base镜像占用空间为何如此小呢？主要是因为，Base镜像的Kernel直接使用宿主的Kernel，例如一些`linux`发行版本的base镜像，如Centos
```shell
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
centos        latest    5d0da3dc9764   2 years ago   231MB
```

只占用231MB。

**Linux 文件系统**由 `bootfs`和 `rootfs` 两部分组成。bootfs(boot file system) 主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel(内核)，当 kernel 被加载到内存中后 bootfs 就被 umount (卸载)了。

在Linux操作系统启动时，系统首先挂载一个只读的rootfs，核查完整性后转为读写模式。

Docker采用类似方法：启动时，Docker daemon将容器的rootfs设为只读，并通过联合挂载技术加上一个读写层。这使得任何文件变更都仅写入顶层的读写层，隐藏下层只读文件的旧版本。

实际上Base镜像只提供一层文件系统`rootfs`。不同 Linux 发行版的区别主要就是 `rootfs`。

但是这也有一些**弊端**，导致**容器的内核版本只能和宿主机一致**，想要不同的内核版本的话，就需要另行安装虚拟机或者物理机了。

**示意图**

```
-----------------------
|     centos rootfs    |        <--- Base image /rootfs image（基础镜像或根镜像）
----------------------------
|      bootfs kernel        |  <--- 宿主机Kernel
----------------------------
```



## 镜像的存储和管理方式

一个镜像由多个镜像层组成。

```
----------------------
| writable Container |             <--- 运行容器时，所有改动都会记录在这层
-------------------------
|        add emacs      |          <--- Image
--------------------------
|        add Apache      |         <--- Image
-----------------------------
|      Centos rootfs        |      <--- Base image
--------------------------------
|           Kernel             |   <--- 宿主机Kernel
--------------------------------
```

用户的镜像**必须**构建在基础镜像之上。

当需要修改容器镜像内的某个文件时，只对处于最上方的读写层进行变动，不覆写下层已有文件系统的内容，已有文件在只读层中的原始版本仍然存在，但会被读写层中的新版本所**隐藏**。



## 写时复制策略

当Docker容器启动时，它基于镜像创建一个新的容器。镜像本身由多个层组成，这些层在不同容器间是共享的，并且是只读的。当容器需要修改已有的文件（或写入新文件）时，写时复制策略就发挥作用了：

1. **检测到写入操作**：当容器尝试修改一个文件时，系统首先检测该文件是否位于只读层。
2. **复制文件到可写层**：如果文件是只读的，Docker会将该文件从只读层复制到容器的顶层（可写层）。这个过程是透明的，对运行中的应用是不可见的。
3. **重定向写入**：一旦文件被复制到可写层，所有对该文件的修改都将发生在这个新的位置。这样，原始的只读文件保持不变，而修改只影响当前容器。

容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。