# MySQL记录的存储



## 表空间文件的结构

```
          (Tablespace)											(Segment)
----------------------------------                  ------------------------------------
|    _______________________     |                  |   ------------    ------------    |
|    |        segment      | ----|--------------->  |   |  Extent  |    |  Extent  |    |
|    |_____________________|     |                  |   ------------    ------------    |
|    _______________________     |                  |   ------------    ------------    |
|    |        segment      |     |                  |   |  Extent  |    |  Extent  |    |
|    |_____________________|     |                  |   ------------    ------------    |
|                                |                  |                         |         |
----------------------------------                  -------------------------------------
                                                                              |
----------------------------------                                            |
|    -----------------------     |                                            |
|    |          row        |     |                                            v
|    -----------------------     |                  ------------------------------------
|    -----------------------     |                  |   -----  -----    -----  -----    |
|    |         row         |     |<-----------------|--|Page ||Page |  |Page ||Page|    |
|    -----------------------     |                  |   -----  -----    -----  -----    |
|    -----------------------     |                  |   -----  -----    -----  -----    |
|    |         row         |     |                  |  |Page ||Page |  |Page ||Page|    |
|    -----------------------     |                  |   -----  -----    -----  -----    |
|                                |                  |                                   |
----------------------------------                  -------------------------------------
			(Page)                                              (Extent)
```



### Row

表数据都是按行存储的，不同行格式的存储结构也有差异



### Page

**`InnoDB`的数据按照页为单位进行读写**,可以减少`IO`次数。**默认页大小为16KB**。数据页也分为很多结构。



### Extent

为了使`B+`树每一个节点存储的数据更多，即让连续存储空间变大，随机`IO`次数变少，存储单位扩展为区（Extent）。

**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**。

#### 

### Segment

由多个区组成

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合



## ` InnoDB`格式

**Redundant** 非紧凑行格式

**Compact**  紧凑型行格式，5.1版本后默认为Compact行格式

**Dynamic & Compressed** 紧凑行格式，5.7版本后默认为Dynamic





## Compact行格式



### 记录的额外信息



#### 1.变长字段长度列表

变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**，这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。 **NULL 值列表**的信息也需要逆序存放

当数据表没有变长字段的时候，这时候表里的行格式就不会有「变长字段长度列表」了



#### 2.NULL值列表

也是只有存在允许NULL值的列才会有NULL值列表。它也是逆序放置的。

每一列对应一个Bit，0为非NULL，1为NULL。

NULL 值列表必须用**整数个字节**的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`。当然了，超过8个列允许NULL就变成两个字节，以此类推。



#### 3. 记录头信息

其中

- `delete_mask` ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 `delete_mask` 标记为 1。
- `next_record`：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- `record_type`：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

从中可知，一条数据被删除**不是真正地被销毁了，只是`delete_mask`位置为1了**。



###  记录的真实数据

除了实际数据，还有三个隐藏的字段

`row_id`：如果没有主键也没有唯一约束，`MySQL`会自动设置一个`row_id`字段。6个字节。

`trx_id`：指定该数据由哪个事务生成的。`trx_id`是必需的，6字节。

`roll_pointer`：一个指向上一个版本的指针，必需的。7字节。





# `varchar`中的n的最大取值

这个问题的答案不是一个固定的数，与**表的字段、字段是否允许为NULL、字符集**等因素有关。

一行数据的**最大字节数是 65535**（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 **storage overhead**（「变长字段长度列表」和 「NULL 值列表」）

所以计算n的最大取值时，需要删去变长字段长度列表」和 「NULL 值列表」。



假如创建一张表
```Mysql
CREATE TABLE test ( 
`name` VARCHAR(???)  NULL
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

只有一个字段，而且可以为NULL。变长字段列表只需表示`name`字段，`name`字段的最大长度超过了255、小于65535（16位最大二进制数）且字符集为`ASCII`，所以变长字段长度列表需要2字节。

在数据库表**只有一个 varchar(n) 字段**且字符集是 **`ASCII`** 的情况下，一个字符最多需要**一个字节**，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = **65532**

在 **UTF-8 字符集**下，一个字符最多需要**三个字节**，varchar(n) 的 n 最大取值就是 65532/3 = **21844**



# 行溢出

一些大对象如 `TEXT`、`BLOB`的大小可能超出了一页的最大值（65535），也就是**行溢出**，需要**溢出页**进行处理。

#### Compact格式处理方法

在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。

#### Compressed 和 Dynamic处理方法

真是数据处不存放实际数据了，而只有20字节指针，全部数据放到指针指向的溢出页中。

# NULL 和 '' 的区别（为什么 MySQL 不建议使用 `NULL` 作为列默认值）

`NULL` 跟 `''`(空字符串)是两个完全不一样的值，区别如下：

- `NULL` 代表一个不确定的值,就算是两个 `NULL`,它俩也不一定相等。例如，`SELECT NULL=NULL`的结果为 false，但是在我们使用`DISTINCT`,`GROUP BY`,`ORDER BY`时,`NULL`又被认为是相等的。
- `''`的长度是 0，是不占用空间的，而`NULL` 是需要占用空间的。
- `NULL` 会影响聚合函数的结果。例如，`SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。 `COUNT` 的处理方式取决于参数的类型。如果参数是 `(COUNT(*)`，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名(`COUNT(列名)`)，则会忽略 `NULL` 值，只统计非空值的个数。
- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULLl` 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而`''`是可以使用这些比较运算符的。

看了上面的介绍之后，相信你对另外一个高频面试题：“为什么 MySQL 不建议使用 `NULL` 作为列默认值？”也有了答案。

### 

















