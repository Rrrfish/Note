# `MySQL`执行流程

## `MySQL`的传输协议

`MySQL`基于TCP进行传输，进行连接时需要经过TCP三次握手。

`MySQL`的通信协议主要经历了两个阶段：基于文本的协议和基于`TCP/IP`的二进制协议。早期的`MySQL`版本使用基于文本的协议，但由于其性能和可扩展性的限制，逐渐被基于`TCP/IP`的二进制协议所取代。二进制协议具有更高的传输效率和更好的可扩展性，成为`MySQL`的主流通信协议。

## 连接器

### 主要工作

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

### 详细过程

`Linux`上进行`MySQL`连接需要以下命令

```shell
msyql -h$ip -u$user -p$password
```

如果进行本地连接就可以没有`-h`，为了安全起见`-p`后可以不加密码，这样将会在`MySQL`内部交互输入密码。

如果后续的用户和密码对应正确，`连接器`将会获取该用户的权限，然后保存起来，后续该用户在此链接内的所有操作都会基于这个权限进行权限逻辑判断。

这里的权限逻辑指的是：数据库在用户尝试执行特定操作时，如查询、更新或删除数据，检查用户是否拥有执行该操作的权限。

`show processlist`可以查看当前有多少客户端连接了这个`MySQL`服务，以下是输出示例。

```mysql
mysql> show processlist
    -> ;
+----+-----------------+-----------+------+---------+------+------------------------+------------------+
| Id | User            | Host      | db   | Command | Time | State                  | Info             |
+----+-----------------+-----------+------+---------+------+------------------------+------------------+
|  5 | event_scheduler | localhost | NULL | Daemon  | 2951 | Waiting on empty queue | NULL             |
| 21 | root            | localhost | NULL | Query   |    0 | init                   | show processlist |
+----+-----------------+-----------+------+---------+------+------------------------+------------------+
2 rows in set, 1 warning (0.00 sec)
```

分析一下上面的输出：

**Id**：这是进程的唯一标识符。在你的输出中，有两个进程，ID 分别为 5 和 21。
**User**：这表示运行该进程的 MySQL 用户。例如，用户 `root` 和 `event_scheduler` 正在运行这些进程。
**Host**：这显示了发起连接的客户端的主机名或 IP 地址。这里都显示为 `localhost`，意味着这些连接都是从服务器本机发起的。
**db**：这一列显示进程正在使用的数据库。在这个例子中，两个进程都没有当前正在使用的特定数据库（显示为 `NULL`）。
**Command**：这表示进程正在执行的命令类型。`Daemon` 通常是内部进程，如 `event_scheduler`；`Query` 表示正在执行查询。
**Time**：这显示了进程已经处于当前状态的秒数。例如，ID 为 5 的进程已经在 `Waiting on empty queue` 状态 2951 秒。
**State**：这描述了进程当前的状态。例如，`Waiting on empty queue` 指的是事件调度器等待新任务的状态；`init` 表示进程正在初始化或刚刚开始执行一个操作。
**Info**：如果进程正在执行 `SQL` 语句，这一列会显示该语句。在输出中，ID 为 21 的进程正在执行 `show processlist` 命令。

其中的两个用户有`root`和`event_scheduler`，ID 为 5 的进程是事件调度器（`event_scheduler`），这是 `MySQL` 的内部进程，用于处理定时事件，当前没有任务执行。ID 为 21 的进程是通过 `mysql` 命令行客户端创建的会话，目前正在执行 `show processlist` 查询。

有时，**`Command`**还会有`sleep`类型，这表示此用户连接完`MySQL`之后就没有任何的操作了，也就是空闲连接。



### 最大空闲时长

空闲连接不会一直占用着的，`MySQL`设置了最大空闲时长，由 `wait_timeout` 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。



### 长连接、短连接和连接池

#### 短连接

是指程序和数据库通信时需要建立连接，执行操作后，连接关闭。

在慢速网络下使用短连接，连接的开销会很大。在生产繁忙的系统中，连接也可能会受到系统端口数的限制，如果要每秒建立几千个连接，那么连接断开后，端口不会被马上回收利用，必须经历一个“FIN”阶段的等待，直到可被回收利用为止，这样就可能会导致端口资源不够用。

#### 长连接

是指程序之间的连接在建立之后，就一直打开，被后续程序重用。但是长连接存在内存占用过高的问题。

#### 连接池

由于一些数据库创建和销毁连接的开销很大，或者相对于所执行的具体数据操作，连接所耗的资源过多，此时就可能需要添加连接池来改进性能。

数据库连接池是一些网络代理服务或应用服务器实现的特性，如`J2EE`服务器，它实现了一个持久连接的“池”，允许其他程序、客户端来连接，这个连接池将被所有连接的客户端共享使用，连接池可以加速连接，也可以减少数据库连接，降低数据库服务器的负载。



### 如何解决长连接内存占用过高

1. 定期断开长连接
2. 客户端主动重连接：`MySQL` 5.7 版本实现了 **接口函数**`mysql_reset_connection()`。那么当客户端执行了一个很大的操作后，在代码里调用 `mysql_reset_connection` 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



### 接口函数和命令

#### 接口函数

`MySQL` 接口函数通常指的是在编程语言中用来与 `MySQL` 数据库进行交互的一组函数或方法。这些函数是各种编程语言（如 `PHP`、Python、Java、C# 等）的库或框架中提供的，用于执行诸如连接数据库、执行` SQL `语句、处理结果集、关闭连接等操作。

#### 命令

`MySQL` 命令则是直接在 `MySQL` 命令行客户端或通过 `SQL` 脚本文件执行的 `SQL` 语句。这些命令用于管理数据库、表、数据行等，如 `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `DROP TABLE` 等。这些命令直接与 `MySQL` 数据库进行交互，执行数据操作或数据库管理任务。



## 查询缓存

`MySQL`8.0之后就取消了查询缓存，但不是`InnoDB`的`Buffer pool`，这两个是不同的概念。

**查询缓存**（Query Cache）是`Server`层的功能。

**`InnoDB`缓冲池**(`Buffer pool`)是` InnoDB` 存储引擎特有的一个机制，用于缓存表数据和索引数据。它是物理磁盘存储和数据库服务器之间的缓冲区，可以提高数据读取的速度，减少磁盘 I/O 操作。缓冲池中缓存的是数据页（通常是表的行数据和索引信息），而不是查询结果。

**区别**

- **数据类型**：查询缓存存储的是整个查询结果的副本，而缓冲池存储的是数据页。
- **失效机制**：查询缓存对数据修改非常敏感，任何涉及表的修改都会导致相关查询缓存失效。缓冲池则主要处理数据页的有效性和一致性，通过 `LRU` 算法等策略管理数据页的生命周期。
- **目的和效果**：查询缓存主要用于减少对已知查询结果的重复计算，而缓冲池的目的是减少数据库的磁盘 I/O，优化数据的读写速度。



## 解析`SQL`

### 解析器

它有两个任务，**词法分析**和**语法分析**



## 执行`SQL`

有三个阶段

- prepare 阶段，也就是预处理阶段；
- optimize 阶段，也就是优化阶段；
- execute 阶段，也就是执行阶段；

### 预处理器

略



### 优化器

#### 覆盖索引（Covering Index）

覆盖索引是指一个索引包含了查询所需的所有字段的数据。换句话说，如果一个查询可以仅通过索引来获取其需要的数据，而不必读取数据表的实际行，那么这个索引就是覆盖索引。使用覆盖索引可以显著提高查询效率，因为它减少了对数据库表的访问次数。

#### 二级索引

在 `InnoDB `存储引擎中，所有的二级索引（非主键索引）的叶子节点除了包含指定的索引字段外，还会存储对应行的主键值。
二级索引，还可以对多个字段建立联合索引，比如，`name` + `age` + `sex`。此时联合索引与单个字段的索引原理是一样的，只不过叶子节点的数据页里放的是id + name + age + sex，然后默认按照name排序，name一样就按age排序，age一样就按sex排序。

#### 例一

见小林coding-`MySQL`基础篇的优化器部分，`select id from product where id > 1 and name like 'i%' ;`（其中`id`为主键，`name`为普通索引）这句就是**覆盖索引**的好例子，只需进行二级索引的查询就可以完成这个查询语句。

#### 例二

`select * from user where name=‘xxx'`，其中`name`是普通索引。
这个查询过程是这样的，首先通过二级索引的B+树进行搜索，但是这里的叶子结点的数据页并没有完整的字段，所以需要用查询到的主键再从主键索引的树中进行查询，这个过程叫做**回表**。



### 执行器

有三种执行方式，分别是：主键索引查询，全表扫描，**索引下堆**。









